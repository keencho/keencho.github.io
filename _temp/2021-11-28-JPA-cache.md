---
title: JPA 캐시
author: keencho
date: 2021-11-27 17:12:00 +0900
categories: [JPA]
tags: [Spring, JPA]
---

# **JPA 캐시**
데이터베이스에 접근하는 비용은 매우 비쌉니다. 실제 운영하는 서비스라면 DB가 같은 시스템 안에 존재하는 일이 없기 때문에 네트워크 비용까지 발생합니다. 결과값을 뻔히 알 수 있는 쿼리에 대해 이런 값비싼 작업을 수행한다면 어플리케이션의 성능은 낮아질 것입니다.

하이버네이트를 포함한 JPA 구현체들은 캐시를 지원합니다. 하이버네이트의 캐시는 어플리케이션과 데이터베이스 사이에 중간다리 계층 역할을 하며, 데이터베이스를 직접 호출하는 대신 서버 메모리에서 결과값을 반환하므로 데이터를 얻는데 걸리는 시간을 줄여줄뿐 아니라 어플리케이션의 성능까지 높일 수 있습니다.

## **1차 캐시**
1차캐시부터 살펴보겠습니다. 1차캐시는 영속성 컨텍스트 내부에 엔티티를 보관하는 장소를 의미합니다. 1차캐시는 하이버네이트에서 기본적으로 사용되도록 설정되어 있습니다. 1차캐시는 트랜잭션을 시작하고 종료할 때까지만 존재합니다.

![first-level-cache](/assets/img/custom/spring/jpa/cache/first-level-cache.png)
플로우를 간단히 도식화해보면 위와 같습니다. 요청이 오면 1차 캐시에서 요청과 일치하는 엔티티가 있는지 확인합니다. 만약 있다면 그대로 해당 엔티티를 반환하고 없다면 db에서 실제로 조회 후에 1차 캐시에 저장 후 해당 결과값을 반환합니다.

### **예제**
간단한 예제를 통해 1차 캐시가 잘 동작하는지 확인해보겠습니다.

테스트에 활용된 설정 정보는 다음과 같습니다.

build.gradle
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.7.1'

    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

application.yml
```yml
spring:
  datasource:
    driver-class-name: org.h2.Driver
    url: jdbc:h2:../test
    username: sa
    password:
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
```

코드는 다음과 같습니다.

TestModel.java
```java
@Entity
@Data
@NoArgsConstructor
@Table(name = "test_model")
public class TestModel {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    Long id;

    String keyword;

}
```

TestService.java
```java
@Service
public class TestService {

    @Autowired
    TestRepository testRepository;

    @Transactional
    public void insertDummyData() {
        var r = Arrays.asList("banana", "monkey", "apple", "bear");

        Random rand = new Random();
        for (var a = 0; a < 10; a ++) {
            TestModel testModel = new TestModel();
            testModel.setKeyword(r.get(rand.nextInt(r.size())));

            testRepository.save(testModel);
        }
    }
}
```

Test.java
```java
@Test
@Transactional
void test() {

    testService.insertDummyData();

    var listAll = testRepo.findAll();

    Assert.notNull(listAll, "ENTITY LIST SHOULD NOT BE NULL");

    for (var i = 1L; i <= 10L; i ++) {
        var entity = testRepo.findById(i).orElse(null);

        Assert.notNull(entity, "ENTITY SHOULD NOT BE NULL");
    }

    var entity = testRepo.findById(12L).orElse(null);

    Assert.isNull(entity, "ENTITY SHOULD BE NULL");
}
```

10개의 엔티티를 저장하고 `testRepo.findAll()` 로 모든 엔티티를 불러와 1차캐시에 저장하였습니다. 만약 1차 캐시가 없다면 반복문 부분에서 1L부터 10L까지 10번 조회하는 쿼리가 날라갈 것입니다.

![first-level-cache-ex](/assets/img/custom/spring/jpa/cache/first-level-cache-ex.png)
하지만 위와 같이 `select * from test_model`절 이후에 반복문 내부의 `findById()` 로 생성되고 실행되어야 할 쿼리는 생성되지 않고 바로 `testRepo.findById(12L).orElse(null)`의 쿼리인 `select * from test_model where id=12`절이 실행된것을 확인할 수 있습니다.

이로써 `findAll()` 로 조회된 id 1~10까지의 엔티티는 1차캐시에서 바로 반환되었고 1차캐시에 존재하지 않는 id 12의 경우 쿼리가 생성되어 실제 db에서 조회하여 결과값을 반환한 것을 확인할 수 있습니다.

## **2차 캐시**  
1차 캐시가 트랜잭션 단위의 캐시라면 2차 캐시는 어플리케이션 단위의 캐시입니다. 따라서 어플리케이션을 시작하고 종료할 때까지 캐시가 유지됩니다.  

![second-level-cache](/assets/img/custom/spring/jpa/cache/second-level-cache.png)  
2차 캐시의 플로우를 도식화 하였습니다. 1차 캐시와 DB 사이에 2차 캐시 레이어가 추가되었습니다. 1차, 2차 캐시에 모두 원하는 요청값이 없는 경우 DB에서 조회후 2차캐시, 1차캐시에 순차적으로 저장 후 결과값을 반환합니다.  

### **Region Factory**  
하이버네이트 2차 캐시는 실제로 어떤 캐시 프로바이더가 사용되는지 알 수 없게 설계되었습니다. 하이버네이트는 `org.hibernate.cache.spi.RegionFactory` 인터페이스를 구현한 구현체만을 필요로 합니다.  

위 인터페이스는 실제 캐시 프로바이더와 관련된 모든 정보를 캡슐화합니다. 또한 기본적으로 하이버네이트와 캐시 프로바이더 사이의 브릿지 역할을 합니다.  

아래 예제에서는 Ehcache를 사용합니다. `RegionFactory` 인터페이스가 구현되어있는 어떤 구현체를 사용해도 문제 없습니다.



