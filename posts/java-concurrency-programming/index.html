<!DOCTYPE html><html lang="ko-KS" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="자바 동시성 프로그래밍 - 메모리 모델과 동기화부터 고급 기법까지" /><meta name="author" content="keencho" /><meta property="og:locale" content="ko_KS" /><meta name="description" content="1. 서론" /><meta property="og:description" content="1. 서론" /><link rel="canonical" href="https://keencho.github.io/posts/java-concurrency-programming/" /><meta property="og:url" content="https://keencho.github.io/posts/java-concurrency-programming/" /><meta property="og:site_name" content="keencho’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-15T08:12:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="자바 동시성 프로그래밍 - 메모리 모델과 동기화부터 고급 기법까지" /><meta name="twitter:site" content="@" /><meta name="twitter:creator" content="@keencho" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"keencho"},"dateModified":"2023-05-15T08:12:00+09:00","datePublished":"2023-05-15T08:12:00+09:00","description":"1. 서론","headline":"자바 동시성 프로그래밍 - 메모리 모델과 동기화부터 고급 기법까지","mainEntityOfPage":{"@type":"WebPage","@id":"https://keencho.github.io/posts/java-concurrency-programming/"},"url":"https://keencho.github.io/posts/java-concurrency-programming/"}</script><title>자바 동시성 프로그래밍 - 메모리 모델과 동기화부터 고급 기법까지 | keencho's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="keencho's blog"><meta name="application-name" content="keencho's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/custom/keencho.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">keencho's blog</a></div><div class="site-subtitle font-italic">이것저것 정리하는 블로그.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/keencho" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['seyoung050412','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>자바 동시성 프로그래밍 - 메모리 모델과 동기화부터 고급 기법까지</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>자바 동시성 프로그래밍 - 메모리 모델과 동기화부터 고급 기법까지</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1684105920" data-df="ll" data-toggle="tooltip" data-placement="bottom"> May 15, 2023 </em> </span><div class="d-flex justify-content-between"> <span> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8097 words"> <em>44 min</em> read</span></div></div></div><div class="post-content"><h1 id="1-서론"><strong>1. 서론</strong></h1><h2 id="11-동시성-프로그래밍의-중요성과-자바-메모리-모델의-역할"><span class="mr-2"><strong>1.1 동시성 프로그래밍의 중요성과 자바 메모리 모델의 역할</strong></span><a href="#11-동시성-프로그래밍의-중요성과-자바-메모리-모델의-역할" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>동시성 프로그래밍은 현대 소프트웨어 개발에서 매우 중요한 개념입니다. 동시성은 여러 개의 작업이 동시에 실행되는 것을 의미하며, 이는 프로그램의 성능과 반응성을 향상시킬 수 있습니다. 하지만 동시에 실행되는 작업들 간의 상호작용은 잘못된 결과나 예상치 못한 동작을 초래할 수도 있습니다.</p><p>자바 메모리 모델은 동시성 프로그래밍에서 스레드 간의 상호작용과 메모리의 동기화를 관리하는 역할을 합니다. 메모리 모델은 스레드가 공유 변수를 읽고 쓸 때의 동작 방식과 가시성 등을 규정합니다. 이를 통해 스레드 간의 안전한 데이터 공유와 일관된 실행 결과를 보장할 수 있습니다.</p><h2 id="12-동시성-문제와-그로-인해-발생할-수-있는-버그와-성능-이슈"><span class="mr-2"><strong>1.2 동시성 문제와 그로 인해 발생할 수 있는 버그와 성능 이슈</strong></span><a href="#12-동시성-문제와-그로-인해-발생할-수-있는-버그와-성능-이슈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>동시성 프로그래밍은 여러 동시 실행되는 스레드들 사이에서 발생하는 문제를 다루는데, 주요한 문제들은 다음과 같습니다:</p><ol><li>경합 상태(Race Condition): 여러 스레드가 동시에 공유 변수에 접근하여 수정하는 경우, 의도치 않은 결과가 발생할 수 있습니다. 스레드 간의 실행 순서나 타이밍에 따라 결과가 달라지며, 이로 인해 버그가 발생할 수 있습니다.<li>교착상태(Deadlock): 두 개 이상의 스레드가 서로가 가진 자원을 기다리며 무한히 대기하는 상태입니다. 이로 인해 프로그램이 멈추는 현상이 발생하며, 제대로 동작하지 않는 원인이 될 수 있습니다.<li>스레드 안전성 문제: 여러 스레드가 동시에 같은 자료구조나 객체를 수정하는 경우, 예기치 않은 결과가 발생할 수 있습니다. 이로 인해 잘못된 데이터 처리, 일관성 없는 상태 등의 문제가 발생할 수 있습니다.</ol><p>또한 동시성은 성능에도 영향을 미칠 수 있습니다. 스레드 간의 경쟁이나 동기화 메소드의 과도한 호출은 소요된 시간 및 자원의 비용을 증가시킬 수 있습니다. 동시에 실행되는 스레드들이 서로 경쟁하거나 동기화를 위해 대기하는 경우, 성능 저하가 발생할 수 있습니다. 특히, 잘못된 동기화 기법이 사용될 경우 스레드 간의 대기 시간이 늘어나거나 병목 현상이 발생할 수 있습니다.</p><p>따라서 동시성 문제를 올바르게 다루고 해결하는 것은 중요합니다. 올바른 동기화 기법과 스레드 간의 협력 및 통신 방법을 사용하여 동시성 문제를 예방하고, 성능 이슈를 최소화할 수 있습니다.</p><h1 id="2-자바-스레드-모델과-스레드-안정성"><strong>2. 자바 스레드 모델과 스레드 안정성</strong></h1><h2 id="21-자바에서-스레드를-생성하고-관리하는-방법"><span class="mr-2"><strong>2.1 자바에서 스레드를 생성하고 관리하는 방법</strong></span><a href="#21-자바에서-스레드를-생성하고-관리하는-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>자바에서는 <code class="language-plaintext highlighter-rouge">Thread</code> 클래스를 상속받거나 <code class="language-plaintext highlighter-rouge">Runnable</code> 인터페이스를 구현하여 스레드를 생성하고 실행할 수 있습니다. <code class="language-plaintext highlighter-rouge">Thread</code> 클래스를 상속받은 경우 <code class="language-plaintext highlighter-rouge">run()</code> 메서드를 오버라이드하여 스레드가 실행할 코드를 작성합니다. <code class="language-plaintext highlighter-rouge">Runnable</code> 인터페이스를 구현한 경우 <code class="language-plaintext highlighter-rouge">run()</code> 메서드를 구현하고, 해당 객체를 <code class="language-plaintext highlighter-rouge">Thread</code> 클래스의 생성자에 전달하여 스레드를 생성합니다.</p><p>스레드는 <code class="language-plaintext highlighter-rouge">start()</code> 메서드를 호출하여 실행됩니다. JVM은 스레드를 스케줄링하여 실행하며, 여러 스레드가 동시에 실행될 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="c1">// Thread 클래스를 상속받아 스레드 생성하기</span>
<span class="kd">class</span> <span class="nc">MyThread</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 스레드가 실행할 작업을 작성</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"스레드가 실행됩니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Runnable 인터페이스를 구현하여 스레드 생성하기</span>
<span class="kd">class</span> <span class="nc">MyRunnable</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 스레드가 실행할 작업을 작성</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"스레드가 실행됩니다."</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// Thread 클래스를 상속받은 스레드 생성하기</span>
        <span class="nc">MyThread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyThread</span><span class="o">();</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 스레드 실행</span>

        <span class="c1">// Runnable 인터페이스를 구현한 스레드 생성하기</span>
        <span class="nc">MyRunnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyRunnable</span><span class="o">();</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span> <span class="c1">// 스레드 실행</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="22-스레드-안전성-개념과-스레드-안전한-코드의-필요성"><span class="mr-2"><strong>2.2 스레드 안전성 개념과 스레드 안전한 코드의 필요성</strong></span><a href="#22-스레드-안전성-개념과-스레드-안전한-코드의-필요성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>스레드 안전성은 여러 스레드가 동시에 접근해도 안전하게 동작하는 코드를 의미합니다. 스레드 안전한 코드는 경합 상태(Race Condition)와 같은 동시성 문제를 피하고, 정확하고 일관된 결과를 보장합니다.</p><p>스레드 안전한 코드를 작성하기 위해서는 동기화(Synchronization) 메커니즘을 사용해야 합니다. 동기화를 통해 여러 스레드가 동시에 접근하더라도 데이터의 일관성과 안정성을 보장할 수 있습니다. 자바에서는 synchronized 키워드를 사용하여 메서드 또는 블록을 동기화할 수 있습니다.</p><p>스레드 안전한 코드는 다중 스레드 환경에서 안전하게 동작하는데, 이는 프로그램의 정확성과 신뢰성을보장합니다. 스레드 안전한 코드는 동시성 문제로부터 자유로워져 예기치 않은 버그와 잠재적인 문제를 방지할 수 있습니다. 따라서 개발자는 스레드 안전성을 고려하여 코드를 작성하고, 필요한 동기화 메커니즘을 적절히 사용하여 데이터의 일관성과 안정성을 확보해야 합니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Counter</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="c1">// synchronized 키워드를 사용하여 동기화된 메서드</span>
    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">count</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Counter</span> <span class="n">counter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Counter</span><span class="o">();</span>

        <span class="c1">// 여러 스레드에서 동시에 increment() 메서드 호출</span>
        <span class="nc">Runnable</span> <span class="n">runnable</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">counter</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">};</span>

        <span class="c1">// 여러 스레드 생성</span>
        <span class="nc">Thread</span> <span class="n">thread1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
        <span class="nc">Thread</span> <span class="n">thread2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>

        <span class="c1">// 스레드 실행</span>
        <span class="n">thread1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">thread2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 스레드 실행이 완료될 때까지 대기</span>
            <span class="n">thread1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
            <span class="n">thread2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="c1">// 최종 결과 출력</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Count: "</span> <span class="o">+</span> <span class="n">counter</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h1 id="3-자바-메모리-모델memory-model"><strong>3. 자바 메모리 모델(Memory Model)</strong></h1><h2 id="31-자바-메모리-모델-개념과-목적"><span class="mr-2"><strong>3.1 자바 메모리 모델 개념과 목적</strong></span><a href="#31-자바-메모리-모델-개념과-목적" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>자바 메모리 모델은 멀티스레드 환경에서 스레드들이 메모리를 공유하는 방식과 동작을 정의하는 규칙의 모음입니다. 목적은 다음과 같습니다.</p><ul><li>스레드 간의 동작과 상호작용을 정확하게 제어하기 위해 일관된 동작을 보장합니다.<li>다중 스레드로부터 안전하게 공유된 데이터에 접근할 수 있는 방법을 제공합니다.</ul><p>자바 메모리 모델은 스레드 간의 상호작용을 통해 가시성(Visibility)와 순서(Ordering)를 관리합니다. 가시성은 한 스레드에서 변경한 데이터가 다른 스레드에 얼마나 빠르게 보이는지를 의미하며, 순서는 연속된 연산의 실행 순서를 의미합니다.</p><h2 id="32-메인-메모리-캐시-메모리-가시성"><span class="mr-2"><strong>3.2 메인 메모리, 캐시, 메모리 가시성</strong></span><a href="#32-메인-메모리-캐시-메모리-가시성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>자바 메모리 모델은 메인 메모리와 캐시(Cache) 등의 다양한 메모리 영역을 다룹니다.</p><ul><li>메인 메모리: 시스템 전체의 주 메모리로 모든 스레드가 공유하는 공간입니다.<li>캐시: 프로세서의 캐시 메모리로 각 코어마다 독립적으로 존재하며, 메인 메모리로부터 데이터를 가져와 캐시에 저장합니다.</ul><p>메모리 가시성은 메인 메모리와 캐시 간의 데이터 일관성을 다루는 개념입니다. 메인 메모리에 저장된 데이터가 캐시에 복사되거나, 캐시에 있는 데이터가 메인 메모리로 반영되는 시점에 따라 스레드 간의 데이터 가시성이 달라집니다.</p><h2 id="33-멀티코어-아키텍처에서의-동작"><span class="mr-2"><strong>3.3 멀티코어 아키텍처에서의 동작</strong></span><a href="#33-멀티코어-아키텍처에서의-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>멀티코어 아키텍처에서는 여러 개의 코어가 병렬로 동작하며, 각 코어마다 독립적인 캐시가 있습니다. 이로 인해 각 스레드가 서로 다른 캐시를 사용하면서 메모리 가시성 문제가 발생할 수 있습니다. 자바 메모리 모델은 이러한 문제를 해결하기 위해 <code class="language-plaintext highlighter-rouge">volatile</code> 키워드와 동기화 기법을 제공합니다.</p><p><code class="language-plaintext highlighter-rouge">volatile</code> 키워드를 사용하여 변수를 선언하면 변수를 메인 메모리에 저장하고 캐시를 건너뛰고 메인 메모리에서 값을 읽고 쓰도록 보장합니다. <code class="language-plaintext highlighter-rouge">volatile</code> 변수를 사용하면 스레드 간의 가시성이 확보되어 데이터의 일관성이 유지됩니다.</p><p>또한 동기화 기법인 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 사용하여 임계 영역을 설정하거나 <code class="language-plaintext highlighter-rouge">Lock</code>과 <code class="language-plaintext highlighter-rouge">Condition</code>을 활용하여 스레드 간의 동기화를 달성할 수 있습니다. 이를 통해 여러 스레드가 동시에 접근하더라도 데이터 일관성과 스레드 안전성을 유지할 수 있습니다.</p><p>자바 메모리 모델은 멀티코어 아키텍처에서의 동작을 고려하여 스레드 간의 메모리 가시성과 일관성을 제어함으로써 동시성 프로그래밍에서 발생할 수 있는 문제를 해결합니다. 이를 통해 안정적이고 정확한 동시성 프로그램을 개발할 수 있습니다.</p><h1 id="4-동기화synchronization"><strong>4. 동기화(Synchronization)</strong></h1><h2 id="41-개념"><span class="mr-2"><strong>4.1 개념</strong></span><a href="#41-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>동기화는 여러 스레드가 동시에 공유된 자원에 접근할 때, 이를 조절하여 데이터의 일관성과 스레드 안전성을 보장하는 메커니즘입니다. 동기화는 경쟁 상태(Race Condition)와 같은 동시성 문제를 해결하고, 스레드 간의 상호작용을 조율하여 예상치 못한 결과를 방지합니다.</p><h2 id="42-자바에서의-동기화-메커니즘"><span class="mr-2"><strong>4.2 자바에서의 동기화 메커니즘</strong></span><a href="#42-자바에서의-동기화-메커니즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>자바에서는 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드와 <code class="language-plaintext highlighter-rouge">volatile</code> 키워드를 제공하여 동기화를 구현할 수 있습니다.</p><ul><li><code class="language-plaintext highlighter-rouge">synchronized</code> 키워드: 메서드나 블록에 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 사용하여 임계 영역을 설정합니다. 임계 영역에 진입한 스레드는 해당 객체의 모니터 락(Monitor Lock)을 획득하고, 다른 스레드는 해당 영역에 진입하지 못하고 대기합니다. 이를 통해 스레드 간의 동기화가 이루어집니다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">synchronizedMethod</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 동기화가 필요한 작업 수행</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">volatile</code> 키워드: <code class="language-plaintext highlighter-rouge">volatile</code> 키워드를 변수에 사용하면 해당 변수의 값을 메인 메모리에 쓰고 읽을 때 캐시를 건너뛰도록 보장합니다. 이를 통해 스레드 간의 가시성을 제공합니다. <code class="language-plaintext highlighter-rouge">volatile</code> 변수는 변수 선언 앞에 <code class="language-plaintext highlighter-rouge">volatile</code> 키워드를 붙여서 사용합니다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">volatile</span> <span class="kt">int</span> <span class="n">sharedVariable</span><span class="o">;</span>
</pre></table></code></div></div><h2 id="43-atomic-클래스"><span class="mr-2"><strong>4.3 Atomic 클래스</strong></span><a href="#43-atomic-클래스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>자바는 <code class="language-plaintext highlighter-rouge">java.util.concurrent.atomic</code> 패키지에서 <code class="language-plaintext highlighter-rouge">Atomic</code>이라는 접두사를 가진 클래스들을 제공합니다. 이들 클래스는 원자적(Atomic) 연산을 수행하여 스레드 간의 동기화를 보장합니다. <code class="language-plaintext highlighter-rouge">AtomicInteger</code>, <code class="language-plaintext highlighter-rouge">AtomicLong</code>, <code class="language-plaintext highlighter-rouge">AtomicBoolean</code> 등의 클래스를 사용하여 원자적인 연산을 수행할 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">AtomicInteger</span> <span class="n">atomicCounter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">();</span>

<span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">atomicCounter</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>어토믹 클래스는 내부적으로 Compare-and-Swap(CAS) 연산을 사용하여 스레드 간의 경쟁 상태를 해결합니다. 이를 통해 동기화 작업을 락 없이 처리할 수 있으며, 성능적으로 우수한 결과를 얻을 수 있습니다.</p><h2 id="44-동기화의-한계"><span class="mr-2"><strong>4.4 동기화의 한계</strong></span><a href="#44-동기화의-한계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>동기화는 스레드 간의 상호작용을 보장하고 스레드 안전성을 보장하는 강력한 메커니즘입니다. 하지만 동기화는 오버헤드와 성능 저하의 가능성이 있습니다. 락을 획득하고 해제하는 과정에서 추가적인 작업이 필요하며, 여러 스레드가 동기화된 영역에 접근하기 위해 경쟁하면서 대기하게 됩니다. 이는 프로그램의 실행 속도를 느리게 만들 수 있습니다.</p><p>또한 동기화의 과도한 사용은 교착상태(Deadlock)와 같은 문제를 발생시킬 수 있습니다. 교착상태는 두 개 이상의 스레드가 서로가 소유한 리소스를 기다리며 무한히 대기하는 상태를 말합니다. 이는 프로그램의 정상적인 실행을 방해하고 데드락을 해결하기 위한 복잡한 알고리즘을 요구합니다.</p><p>따라서 동기화를 사용할 때는 신중하게 접근해야 합니다. 필요한 부분에만 동기화를 적용하고, 동기화의 범위를 최소화하여 성능을 향상시킬 수 있습니다. 또한 교착상태와 같은 문제를 피하기 위해 동기화 코드를 신중하게 설계하고 데드락 상황을 예방할 수 있는 방법을 고려해야 합니다.</p><p>자바에서는 동기화를 위해 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드 외에도 <code class="language-plaintext highlighter-rouge">Lock</code> 인터페이스와 그 구현체인 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>을 제공합니다. <code class="language-plaintext highlighter-rouge">Lock</code>을 사용하면 더 세밀한 제어와 고급 동기화 기능을 활용할 수 있습니다. 하지만 <code class="language-plaintext highlighter-rouge">Lock</code>은 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드보다 사용이 복잡하고 실수할 가능성이 높기 때문에 적절한 상황에서 사용해야 합니다.</p><p>동기화는 스레드 간의 상호작용을 조율하여 스레드 안전성과 데이터 일관성을 보장하는 중요한 개념입니다. 하지만 오버헤드와 성능 저하의 가능성을 고려하여 적절하게 사용해야 합니다.</p><h1 id="5-스레드-간의-협력과-통신"><strong>5. 스레드 간의 협력과 통신</strong></h1><p>스레드 간의 협력과 통신은 동시성 프로그래밍에서 중요한 측면입니다. 여러 스레드가 동시에 실행되는 환경에서는 스레드들이 데이터를 공유하고 상호작용해야 합니다. 자바에서는 몇 가지 메커니즘을 제공하여 스레드 간의 협력과 통신을 가능하게 합니다.</p><h2 id="51-wait-notify-notifyall-메서드"><span class="mr-2"><strong>5.1 wait(), notify(), notifyAll() 메서드</strong></span><a href="#51-wait-notify-notifyall-메서드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">wait()</code>, <code class="language-plaintext highlighter-rouge">notify()</code>, <code class="language-plaintext highlighter-rouge">notifyAll()</code>은 자바의 모든 객체가 가지고 있는 메서드로, 스레드 간의 협력과 통신을 위해 사용됩니다. 이 메서드들은 스레드가 객체의 모니터 락을 확보하고 있을 때 호출해야 합니다.</p><ul><li><code class="language-plaintext highlighter-rouge">wait()</code>: 현재 스레드를 일시적으로 대기 상태로 전환시키고, 다른 스레드가 객체의 모니터 락을 획득하고 <code class="language-plaintext highlighter-rouge">notify()</code> 또는 <code class="language-plaintext highlighter-rouge">notifyAll()</code>을 호출하여 대기 중인 스레드를 깨울 때까지 대기합니다.<li><code class="language-plaintext highlighter-rouge">notify()</code>: 대기 중인 스레드 중 하나를 선택하여 깨웁니다. 선택된 스레드는 모니터 락을 얻을 수 있는 시도를 합니다.<li><code class="language-plaintext highlighter-rouge">notifyAll()</code>: 대기 중인 모든 스레드를 깨웁니다. 깨어난 스레드들은 모니터 락을 얻을 수 있는 시도를 합니다.</ul><h2 id="52-스레드-간의-데이터-공유"><span class="mr-2"><strong>5.2 스레드 간의 데이터 공유</strong></span><a href="#52-스레드-간의-데이터-공유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>스레드 간의 데이터 공유는 동시성 프로그래밍에서 주의해야 할 중요한 측면입니다. 여러 스레드가 동일한 데이터에 접근하면서 데이터 일관성 문제나 경합 상태(Race Condition)와 같은 문제가 발생할 수 있습니다.</p><p>동기화 메커니즘을 사용하여 스레드 간의 데이터 공유를 관리할 수 있습니다. <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 사용하여 메서드나 블록을 동기화할 수 있으며, <code class="language-plaintext highlighter-rouge">volatile</code> 키워드를 사용하여 변수의 가시성과 순서를 보장할 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataSharingExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">sharedData</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sharedData</span><span class="o">++;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">decrement</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">sharedData</span><span class="o">--;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getSharedData</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">sharedData</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="53-스레드-간의-협력"><span class="mr-2"><strong>5.3 스레드 간의 협력</strong></span><a href="#53-스레드-간의-협력" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>스레드 간의 협력은 작업을 조율하고 스레드의 실행 순서를 제어하는 것을 의미합니다. 스레드 간의 협력을 위해 다양한 기법을 사용할 수 있습니다.</p><ul><li><strong>Lock과 Condition</strong>: <code class="language-plaintext highlighter-rouge">Lock</code> 인터페이스와 <code class="language-plaintext highlighter-rouge">Condition</code> 인터페이스는 스레드 간의 협력을 위한 기능을 제공합니다. <code class="language-plaintext highlighter-rouge">Lock</code>은 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드보다 더 세밀한 제어가 가능하며, <code class="language-plaintext highlighter-rouge">Condition</code>은 스레드의 대기와 신호를 관리할 수 있습니다.<li><strong>wait()과 notify()</strong>: 앞서 언급한 <code class="language-plaintext highlighter-rouge">wait()</code>과 <code class="language-plaintext highlighter-rouge">notify()</code> 메서드를 사용하여 스레드 간의 대기와 신호를 조절할 수 있습니다. <code class="language-plaintext highlighter-rouge">wait()</code>을 호출한 스레드는 대기 상태로 전환되며, 다른 스레드가 <code class="language-plaintext highlighter-rouge">notify()</code>을 호출하여 대기 중인 스레드를 깨울 수 있습니다.<li><strong>BlockingQueue</strong>: <code class="language-plaintext highlighter-rouge">BlockingQueue</code> 인터페이스는 스레드 간의 작업을 조율하기 위한 자료구조입니다. 큐에 요소를 추가하거나 제거할 때 스레드가 차단되어 대기하도록 할 수 있습니다. 이를 통해 생산자-소비자 패턴과 같은 협력적인 작업을 구현할 수 있습니다.<li><strong>CountDownLatch</strong>: <code class="language-plaintext highlighter-rouge">CountDownLatch</code> 클래스는 특정 스레드가 여러 개의 작업이 완료될 때까지 대기하는 동안 다른 스레드들이 작업을 수행할 수 있도록 하는 데 사용됩니다. 주로 메인 스레드가 여러 개의 작업 스레드가 완료될 때까지 기다리는 상황에서 활용됩니다.<li><strong>CyclicBarrier</strong>: <code class="language-plaintext highlighter-rouge">CyclicBarrier</code> 클래스는 지정된 수의 스레드가 특정 지점에서 만날 때까지 기다릴 수 있도록 하는 동기화 기법입니다. 모든 스레드가 도착하면 지정된 작업을 수행하거나 다음 단계로 진행할 수 있습니다.</ul><p>이러한 스레드 간의 협력과 통신 기법을 적절하게 활용하면 스레드 간의 작업 조율과 데이터 공유를 효과적으로 관리할 수 있습니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadCooperationExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Lock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">isDataAvailable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">produceData</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 데이터 생성 및 저장</span>
            <span class="n">isDataAvailable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">consumeData</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(!</span><span class="n">isDataAvailable</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 데이터가 생성되기를 기다림</span>
            <span class="o">}</span>
            <span class="c1">// 데이터 소비</span>
            <span class="n">isDataAvailable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h1 id="6-고급-동시성-기법과-패턴"><strong>6. 고급 동시성 기법과 패턴</strong></h1><p>동시성 문제를 해결하기 위해 고급 동시성 기법과 패턴을 사용할 수 있습니다. 이러한 기법과 패턴은 스레드 간의 경합 상태와 성능 문제를 해결하고, 코드의 가독성과 확장성을 향상시키는 데 도움이 됩니다. 이 섹션에서는 일부 일반적인 고급 동시성 기법과 패턴을 살펴보겠습니다.</p><h2 id="61-스레드풀thread-pool"><span class="mr-2"><strong>6.1 스레드풀(Thread Pool)</strong></span><a href="#61-스레드풀thread-pool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>스레드풀은 작업을 처리하기 위해 미리 생성된 스레드의 풀을 유지하고 관리하는 기법입니다. 스레드풀을 사용하면 작업을 처리하기 위해 매번 스레드를 생성하고 제거하는 비용을 줄일 수 있습니다. 대신, 스레드풀에서 사용 가능한 스레드 중 하나를 할당하여 작업을 실행합니다.</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadPoolExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 스레드풀 생성</span>
        <span class="nc">ExecutorService</span> <span class="n">executor</span> <span class="o">=</span> <span class="nc">Executors</span><span class="o">.</span><span class="na">newFixedThreadPool</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>

        <span class="c1">// 작업 제출</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">WorkerThread</span><span class="o">(</span><span class="s">"Task "</span> <span class="o">+</span> <span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">// 작업 완료 후 스레드풀 종료</span>
        <span class="n">executor</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">WorkerThread</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">task</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">WorkerThread</span><span class="o">(</span><span class="nc">String</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">task</span> <span class="o">=</span> <span class="n">task</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 작업 실행</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Executing: "</span> <span class="o">+</span> <span class="n">task</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>위의 예제에서는 <code class="language-plaintext highlighter-rouge">Executors.newFixedThreadPool(5)</code>를 사용하여 크기가 5인 스레드풀을 생성합니다. 10개의 작업을 제출하고 각 작업은 스레드풀에서 사용 가능한 스레드 중 하나에 할당되어 실행됩니다.</p><h2 id="62-락의-종류와-성능"><span class="mr-2"><strong>6.2 락의 종류와 성능</strong></span><a href="#62-락의-종류와-성능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>락은 여러 스레드가 공유 자원에 접근하는 것을 제어하기 위해 사용됩니다. 자바에서는 <code class="language-plaintext highlighter-rouge">synchronized</code> 키워드를 사용하여 단일 스레드에 의한 잠금을 구현할 수 있습니다. 그러나 <code class="language-plaintext highlighter-rouge">synchronized</code>는 단일 스레드에 의한 잠금만 지원하며, 여러 스레드에 의한 동시 접근을 허용하지 않습니다. 이에 대비하여 다양한 락의 종류가 있습니다.</p><ul><li><strong>ReentrantLock</strong>: <code class="language-plaintext highlighter-rouge">synchronized</code>와 유사한 기능을 제공하는 락으로, 재진입 가능 합니다. 재진입 가능한 기능을 제공하는 락으로, <code class="language-plaintext highlighter-rouge">synchronized</code>와 달리 더욱 세밀한 제어가 가능합니다. 다음은 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>의 예제 코드입니다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReentrantLockExample</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">WorkerThread</span><span class="o">());</span>
        <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">WorkerThread</span><span class="o">());</span>

        <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
        <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kd">class</span> <span class="nc">WorkerThread</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span> <span class="c1">// 락 획득</span>

            <span class="k">try</span> <span class="o">{</span>
                <span class="c1">// 임계 영역</span>
                <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Critical section"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span> <span class="c1">// 락 해제</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>위의 예제에서는 <code class="language-plaintext highlighter-rouge">ReentrantLock</code>을 사용하여 임계 영역을 보호합니다. <code class="language-plaintext highlighter-rouge">lock.lock()</code>을 호출하여 락을 획득하고, <code class="language-plaintext highlighter-rouge">lock.unlock()</code>을 호출하여 락을 해제합니다. 이를 통해 여러 스레드 간의 상호 배제를 구현할 수 있습니다.</p><ul><li><strong>ReadWriteLock</strong>: 읽기 작업과 쓰기 작업을 구분하여 여러 스레드가 동시에 읽기 작업을 수행할 수 있도록 지원합니다. 쓰기 작업이 진행 중일 때는 다른 스레드의 쓰기 작업과 읽기 작업이 불가능합니다.<li><strong>StampedLock</strong>: <code class="language-plaintext highlighter-rouge">ReadWriteLock</code>과 유사한 기능을 제공하지만, 읽기 락과 쓰기 락의 개념을 확장하여 조금 더 세밀한 제어가 가능합니다. 추가적으로 optimistic read와 write lock을 지원하여 성능을 향상시킬 수 있습니다.</ul><h2 id="63-thread-safe-collections"><span class="mr-2"><strong>6.3 Thread-Safe Collections</strong></span><a href="#63-thread-safe-collections" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>자바에서는 다양한 Thread-Safe Collection을 제공합니다.</p><ul><li><strong>ConcurrentHashMap</strong>: 동시성 환경에서 안전하게 사용할 수 있는 해시 맵입니다. 여러 스레드가 동시에 맵에 접근하여 요소를 추가, 제거, 검색할 수 있습니다.<li><strong>CopyOnWriteArrayList</strong>: 동시성 환경에서 안전하게 사용할 수 있는 리스트입니다. 요소를 추가하거나 수정하는 작업이 일어날 때, 새로운 복사본을 만들어 작업을 수행합니다. 따라서 읽기 작업은 락 없이 동시에 수행할 수 있습니다.<li><strong>ConcurrentLinkedQueue</strong>: 동시성 환경에서 안전하게 사용할 수 있는 큐입니다. 여러 스레드가 동시에 큐에 접근하여 요소를 추가하거나 제거할 수 있습니다.</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ThreadSafeDataStructureExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// ConcurrentHashMap 예제</span>
        <span class="nc">ConcurrentHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">concurrentMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentHashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">concurrentMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Key1"</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
        <span class="n">concurrentMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"Key2"</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">value1</span> <span class="o">=</span> <span class="n">concurrentMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">"Key1"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">value1</span><span class="o">);</span>

        <span class="c1">// CopyOnWriteArrayList 예제</span>
        <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">copyOnWriteList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CopyOnWriteArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">copyOnWriteList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Item1"</span><span class="o">);</span>
        <span class="n">copyOnWriteList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Item2"</span><span class="o">);</span>
        <span class="nc">String</span> <span class="n">item1</span> <span class="o">=</span> <span class="n">copyOnWriteList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">item1</span><span class="o">);</span>

        <span class="c1">// ConcurrentLinkedQueue 예제</span>
        <span class="nc">ConcurrentLinkedQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">concurrentQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ConcurrentLinkedQueue</span><span class="o">&lt;&gt;();</span>
        <span class="n">concurrentQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">concurrentQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">element</span> <span class="o">=</span> <span class="n">concurrentQueue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">element</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>위의 예제에서는 각각 <code class="language-plaintext highlighter-rouge">ConcurrentHashMap</code>, <code class="language-plaintext highlighter-rouge">CopyOnWriteArrayList</code>, <code class="language-plaintext highlighter-rouge">ConcurrentLinkedQueue</code>를 사용하여 Thread-Safe한 자료구조를 보여줍니다. 이 자료구조들은 여러 스레드에서 안전하게 동작하며, 동시에 요소를 추가하거나 제거할 수 있습니다.</p><h1 id="7-동시성-문제와-디버깅"><strong>7. 동시성 문제와 디버깅</strong></h1><p>동시성 프로그래밍에서는 동시에 실행되는 여러 스레드로 인해 발생할 수 있는 다양한 문제들이 있습니다. 이러한 동시성 문제들은 버그의 원인이 될 뿐만 아니라 성능 저하와 잘못된 동작을 야기할 수 있습니다. 이번 섹션에서는 동시성 프로그래밍에서 주로 발생하는 동시성 문제의 종류와 디버깅 방법에 대해 알아보겠습니다.</p><h2 id="71-경합-상태-race-condition"><span class="mr-2"><strong>7.1 경합 상태 (Race Condition)</strong></span><a href="#71-경합-상태-race-condition" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>경합 상태는 여러 스레드가 공유된 자원에 동시에 접근하고 수정할 때 발생하는 문제입니다. 경합 상태는 예측할 수 없는 결과를 초래하며, 스레드 스케줄링과 같은 환경 변화에 따라 결과가 달라질 수 있습니다. 경합 상태를 해결하기 위해서는 상호 배제(Mutual Exclusion)와 같은 동기화 기법을 사용해야 합니다.</p><h2 id="72-교착상태-deadlock"><span class="mr-2"><strong>7.2 교착상태 (Deadlock)</strong></span><a href="#72-교착상태-deadlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>교착상태는 두 개 이상의 스레드가 서로 상대방이 점유한 자원을 기다리며 무한히 대기하는 상태를 말합니다. 이는 상호 배제, 점유와 대기, 비선점, 순환 대기라는 네 가지 조건이 동시에 충족될 때 발생합니다. 교착상태를 해결하기 위해서는 교착상태의 조건 중 하나를 제거하거나, 교착상태를 회피하기 위한 알고리즘을 사용해야 합니다.</p><h2 id="73-스레드-안전성-문제"><span class="mr-2"><strong>7.3 스레드 안전성 문제</strong></span><a href="#73-스레드-안전성-문제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>스레드 안전성 문제는 여러 스레드가 동시에 접근하는 공유된 데이터의 일관성을 유지하지 못하는 문제입니다. 스레드 간의 데이터 경쟁이 발생하여 데이터 일관성이 깨지거나 잘못된 연산이 수행될 수 있습니다. 스레드 안전성 문제를 해결하기 위해서는 동기화 메커니즘을 사용하거나 스레드 안전한 자료구조를 활용해야 합니다.</p><h2 id="74-동시성-문제-디버깅-방법"><span class="mr-2"><strong>7.4 동시성 문제 디버깅 방법</strong></span><a href="#74-동시성-문제-디버깅-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>동시성 문제를 디버깅하는 것은 다른 종류의 버그를 디버깅하는 것보다 어렵습니다. 동시성 문제는 실행 시점에 따라 결과가 달라질 수 있으며, 일시적이고 재현이 어려워질 수 있습니다. 하지만 몇 가지 디버깅 기법을 활용하여 동시성 문제를 해결할 수 있습니다. 다음은 동시성 문제 디버깅에 도움이 되는 방법들입니다.</p><ul><li>로그 및 출력 문장 분석: 로그와 출력 문장을 분석하여 동시성 문제의 원인을 찾을 수 있습니다. 스레드 간의 순서, 데이터의 상태 및 변경 이력 등을 확인하여 문제를 파악할 수 있습니다.<li>동기화 기법 검토: 동기화 기법의 적용 여부를 검토합니다. 경합 상태를 방지하기 위해 적절한 동기화 메커니즘을 사용하고, 교착상태를 해결하기 위해 교착상태의 조건을 제거하거나 회피 알고리즘을 적용합니다.<li>스레드 동작 분석: 각 스레드의 동작을 분석하여 문제가 발생하는 시점과 조건을 확인합니다. 스레드의 동기화 영역, 공유 데이터 접근, 대기 상태 등을 검토하여 문제의 원인을 찾을 수 있습니다.<li>도구 활용: 다양한 디버깅 도구를 활용하여 동시성 문제를 분석할 수 있습니다. 스레드 덤프 분석 도구, 데드락 검출 도구, 모니터링 도구 등을 사용하여 문제를 진단하고 해결할 수 있습니다.<li>테스트와 검증: 동시성 문제를 방지하기 위해 적절한 테스트와 검증을 수행해야 합니다. 다양한 상황에서의 동시성 동작을 시뮬레이션하고 테스트 케이스를 작성하여 문제를 발견하고 수정할 수 있습니다.</ul><p>동시성 문제는 복잡하고 예측하기 어려운 문제이지만, 위의 디버깅 방법들을 적절히 활용하면 문제를 해결할 수 있습니다. 동시성 문제를 이해하고 적절한 동기화 기법과 디버깅 기법을 사용하여 안정적이고 효율적인 동시성 프로그램을 개발할 수 있도록 노력해야 합니다.</p><h1 id="8-결론"><strong>8. 결론</strong></h1><p>이 글에서는 자바 메모리 모델과 동시성 프로그래밍의 중요성을 강조하였습니다. 동시성 프로그래밍은 효율적이고 안정적인 다중 스레드 애플리케이션을 구현하기 위해 필수적입니다.</p><p>자바 메모리 모델을 이해하고, 적절한 동기화 기법을 사용하여 스레드 간의 동기화를 보장할 수 있습니다. 또한, 동기화를 통해 경합 상태와 같은 동시성 문제를 해결할 수 있습니다.</p><p>스레드 간의 협력과 통신을 위해 wait(), notify(), notifyAll() 메서드를 사용할 수 있으며, 고급 동시성 기법과 패턴을 활용하여 동시성을 개선할 수 있습니다.</p><p>동시성 문제와 디버깅에 대해서는 로그 분석, 동기화 기법 검토, 스레드 동작 분석, 도구 활용, 테스트와 검증 등을 통해 문제를 해결할 수 있습니다.</p><p>자바 메모리 모델과 동시성 프로그래밍에 대한 이해는 안정적이고 효율적인 소프트웨어 개발을 위해 중요합니다. 개발자들은 동시성 프로그래밍에 대한 주의사항을 숙지하고, 적절한 기법과 패턴을 활용하여 안전하고 성능 우수한 애플리케이션을 개발할 수 있어야 합니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/java/'>Java</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%EC%9E%90%EB%B0%94+%EB%8F%99%EC%8B%9C%EC%84%B1+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D+-+%EB%A9%94%EB%AA%A8%EB%A6%AC+%EB%AA%A8%EB%8D%B8%EA%B3%BC+%EB%8F%99%EA%B8%B0%ED%99%94%EB%B6%80%ED%84%B0+%EA%B3%A0%EA%B8%89+%EA%B8%B0%EB%B2%95%EA%B9%8C%EC%A7%80+-+keencho%27s+blog&url=https%3A%2F%2Fkeencho.github.io%2Fposts%2Fjava-concurrency-programming%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%EC%9E%90%EB%B0%94+%EB%8F%99%EC%8B%9C%EC%84%B1+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D+-+%EB%A9%94%EB%AA%A8%EB%A6%AC+%EB%AA%A8%EB%8D%B8%EA%B3%BC+%EB%8F%99%EA%B8%B0%ED%99%94%EB%B6%80%ED%84%B0+%EA%B3%A0%EA%B8%89+%EA%B8%B0%EB%B2%95%EA%B9%8C%EC%A7%80+-+keencho%27s+blog&u=https%3A%2F%2Fkeencho.github.io%2Fposts%2Fjava-concurrency-programming%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fkeencho.github.io%2Fposts%2Fjava-concurrency-programming%2F&text=%EC%9E%90%EB%B0%94+%EB%8F%99%EC%8B%9C%EC%84%B1+%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D+-+%EB%A9%94%EB%AA%A8%EB%A6%AC+%EB%AA%A8%EB%8D%B8%EA%B3%BC+%EB%8F%99%EA%B8%B0%ED%99%94%EB%B6%80%ED%84%B0+%EA%B3%A0%EA%B8%89+%EA%B8%B0%EB%B2%95%EA%B9%8C%EC%A7%80+-+keencho%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/jpa-flush/">JPA & Hibernate Flush Mode</a><li><a href="/posts/aws-cicd-1/">AWS를 사용해 무중단 배포 자동화 환경 구축하기 - 1. 개요</a><li><a href="/posts/terraform-aws-infra-6/">Terraform으로 AWS 무중단 배포 인프라 구성하기 - 6. 운영환경 (백엔드)</a><li><a href="/posts/aapt2-arm/">Arm 아키텍처에서 AAPT2 빌드 도구 사용하기</a><li><a href="/posts/terraform-aws-infra-1/">Terraform으로 AWS 무중단 배포 인프라 구성하기 - 1. 개요</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/ecs/">ECS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/querydsl/">QueryDSL</a> <a class="post-tag" href="/tags/react/">React</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/proxy-pattern/"><div class="card-body"> <em class="small" data-ts="1625310720" data-df="ll" > Jul 3, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>프록시 패턴 (Proxy Pattern)</h3><div class="text-muted small"><p> 프록시 패턴 프록시(Proxy) 는 대리자 라는 뜻입니다. 실생활서의 의미처럼 프로그램에서의 프록시도 누군가에게 어떤 일을 대신 시키는 것 이란 의미를 가지고 있습니다. 때때로 우리는 객체에 대한 액세스를 제어하는 기능을 필요합니다. 예를 들어 무겁고 많은 자원을 필요로 하는 클래스의 한두가지 메소드만 사용해야 하더라도 생성자로 전체 클래스를 인스턴...</p></div></div></a></div><div class="card"> <a href="/posts/singleton-pattern/"><div class="card-body"> <em class="small" data-ts="1625569920" data-df="ll" > Jul 6, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>싱글턴 패턴 (Singleton Pattern)</h3><div class="text-muted small"><p> 싱글턴 패턴 싱글턴 패턴은 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴하는 디자인 유형입니다. 구조 싱글턴 클래스는 자체 클래스의 동일한 인스턴스를 반환하는 getInstance() 라는 정적 메소드를 선언했습니다. 싱글턴의 생성자는 ...</p></div></div></a></div><div class="card"> <a href="/posts/observer-pattern/"><div class="card-body"> <em class="small" data-ts="1625829120" data-df="ll" > Jul 9, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>옵저버 패턴 (Observer Pattern)</h3><div class="text-muted small"><p> 옵저버 패턴 옵저버 패턴은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메스드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴입니다. 구조 게시자는 다른 객체들에게 관심 이벤트를 발행합니다. 이 이벤트난 게시자가 상태를 변경하거나 어떤 동작을 실행할 때 발생합니...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/jooq/" class="btn btn-outline-primary" prompt="Older"><p>JOOQ 알아보기</p></a> <a href="/posts/database-view/" class="btn btn-outline-primary" prompt="Newer"><p>DB 뷰(View)</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://github.com/keencho">keencho</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/aws/">AWS</a> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/jpa/">JPA</a> <a class="post-tag" href="/tags/design-pattern/">Design Pattern</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/hibernate/">Hibernate</a> <a class="post-tag" href="/tags/ecs/">ECS</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/querydsl/">QueryDSL</a> <a class="post-tag" href="/tags/react/">React</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
